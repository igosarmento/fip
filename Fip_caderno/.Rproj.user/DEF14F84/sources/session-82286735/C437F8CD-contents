---
title: "Fip_caderno"
---

This is a Quarto website.

To learn more about Quarto websites visit <https://quarto.org/docs/websites>.

```{r}
1 + 1
```

"Este √© o caderno de aulas pr√°ticas da disciplina FIP-606 ‚Äì An√°lise e Visualiza√ß√£o de Dados em Fitopatologia. Ele serve como material de consulta futura, com c√≥digos para an√°lises estat√≠sticas, al√©m de disponibilizar publicamente as atividades executadas em sala de aula."

# üìò **Aula 1 ‚Äî Importa√ß√£o, Manipula√ß√£o e Visualiza√ß√£o de Dados no R**

Vamos importar um conjunto de dados que est√° dispon√≠vel no R.

Neste trecho, est√° sendo utilizado o dataset `Orange`, que j√° vem embutido no R. Ele cont√©m medidas de crescimento (circunfer√™ncia) de laranjeiras ao longo do tempo. A vari√°vel `dados` armazena esse conjunto para uso posterior.

```{r}
dados <- Orange
Orange
```

**Transforma√ß√µes de dados**

Aqui √© feita a extra√ß√£o da vari√°vel `circumference`, e s√£o aplicadas transforma√ß√µes matem√°ticas comuns em an√°lise de dados:

-   `exp(circ)` calcula o valor exponencial da circunfer√™ncia;

-   `log(circ2)` retorna o logaritmo dos valores transformados.\
    Essas transforma√ß√µes s√£o √∫teis para explorar a distribui√ß√£o dos dados ou atender premissas de normalidade e homogeneidade de vari√¢ncia em an√°lises estat√≠sticas.

```{r}
circ<-dados$circumference
circ2<-exp(circ)
circ2
circ3=log(circ2)
```

# Adi√ß√£o de uma variavel nova nos dados originais:

Neste bloco, √© criada e adicionada ao dataframe original a nova vari√°vel `logcirc`, que representa o logaritmo da circunfer√™ncia. Isso facilita an√°lises futuras, como modelos lineares, que podem se beneficiar de vari√°veis transformadas.

```{r}
dados
dados$logcirc<-log(dados$circumference)
dados
```

# Desagregar um conjunto de dados em variaveis independentes:

Com `attach()`, as vari√°veis do dataframe `dados` passam a estar dispon√≠veis diretamente no ambiente do R, sem a necessidade de usar `$`.

```{r}
attach(dados)
circumference
```

**Instala√ß√£o e uso de pacotes; c√°lculo de AUDPC**

Aqui s√£o carregados os pacotes `agricolae` (para an√°lises agr√≠colas) e `tidyverse` (conjunto de pacotes para ci√™ncia de dados). Em seguida, s√£o definidos vetores com dias e severidade da doen√ßa. A fun√ß√£o `audpc()` calcula a √Årea Abaixo da Curva de Progresso da Doen√ßa (AUDPC), uma m√©trica para quantificar a progress√£o temporal de doen√ßas em plantas.

**Acessando dados do pacote agricolae**

Este bloco carrega e inspeciona o dataset `corn`, tamb√©m do pacote `agricolae`. A fun√ß√£o `str()` √© usada para visualizar a estrutura do conjunto de dados, incluindo tipos de vari√°veis e primeiras observa√ß√µes ‚Äî etapa essencial na explora√ß√£o inicial dos dados.

```{r}
library(agricolae)
library(tidyverse)
dates <- c(14,21,28) # days
severity <- c(40,80,90)
severity
audpc(severity,dates)

data(corn)
corn
str(corn)
```

### Criando gr√°ficos simples com `ggplot2`

Um novo dataframe (`data_curva`) √© criado para representar a evolu√ß√£o da severidade ao longo do tempo. Em seguida, √© feito um gr√°fico combinando colunas (`geom_col`), linha (`geom_line`) e pontos (`geom_point`). Essa abordagem facilita a visualiza√ß√£o de tend√™ncias e flutua√ß√µes temporais de doen√ßas.

```{r}

library(tidyverse)
dates <- c(7,14,21,28,35,42) # days
severity <- c(0.1,5,10,35,50,60)
data_curva<-data.frame(dates,severity)
data_curva
# meu primeiro plot
data_curva |>
  mutate(severity2 = c(1,10,35,58,70,82)) |> 
  ggplot(aes(dates,severity2))+
  geom_col()+
  geom_line(linewidth = 2,color="blue")+
  geom_point(size = 5)+
  theme_classic(base_size = 14)+
  labs(x="Dia ap√≥s o plantio",
       y="severidade(%)")+
  scale_y_continuous(limits = c(0,100),n.breaks = 10)+
  scale_x_continuous(n.breaks = 8)
```

### **Personalizando cores do gr√°fico**

Este gr√°fico repete a visualiza√ß√£o anterior, mas com personaliza√ß√£o de **cores**: barras pretas, linha roxa e pontos pretos. Isso demonstra como `ggplot2` permite criar visualiza√ß√µes estilizadas para apresenta√ß√£o de resultados em artigos, relat√≥rios e slides.

```{r}
data_curva |> 
  mutate(severity2 = c(1,10,35,58,70,82)) |> 
  ggplot(aes(dates, severity2)) +
  geom_col(fill = "BLACK") +  # Barras em roxo
  geom_line(linewidth = 2, color = "PURPLE") +  # Linha em roxo
  geom_point(size = 5, color = "black") +  # Pontos em roxo
  theme_classic(base_size = 14) +
  labs(x = "Dia ap√≥s o plantio",
       y = "severidade(%)") +
  scale_y_continuous(limits = c(0, 100), n.breaks = 10) +
  scale_x_continuous(n.breaks = 8)

```

# üìò **Aula 2 ‚Äî Leitura de Dados e Visualiza√ß√£o com `ggplot2`**

O pacote `tidyverse` √© carregado para garantir acesso a fun√ß√µes essenciais para manipula√ß√£o de dados (`dplyr`, `readr`, `ggplot2`, etc.). Isso √© uma boa pr√°tica em qualquer an√°lise moderna no R.

```{r}
library(tidyverse)
```

# Carregamento e leitura de arquivos Excel com `readxl`

Aqui o pacote `readxl` √© usado para importar uma planilha Excel (`.xlsx`) localizada localmente no computador. A aba (sheet) chamada `"sensibilidade_fungicidas"` √© lida e armazenada no objeto `dados`.

```{r}
library(readxl)
library(tidyverse)
dados <- read_excel("dados.xlsx", sheet = "sensibilidade_fungicidas")
dados 

```

**Inspe√ß√£o da estrutura dos dados**

As fun√ß√µes `str()` e `glimpse()` ajudam a visualizar rapidamente as vari√°veis, tipos de dados e primeiras entradas. Isso √© crucial para entender como manipular ou transformar os dados corretamente.

```{r}
str (dados)
```

```{r}
glimpse(dados)
```

**Lendo diferentes abas do mesmo arquivo Excel**

Testa-se a leitura de outras abas com nomes diferentes (`"sensibilidade-fungicida"` e `"Planilha1"`). Isso √© √∫til quando o mesmo arquivo cont√©m v√°rias tabelas experimentais.

```{r}
dados2 <- read_excel("dados.xlsx",
                  sheet = "sensibilidade-fungicida")
```

```{r}
str(dados2)
```

```{r}
glimpse(dados2)
```

```{r}
dados2 <- read_excel("dados.xlsx",
                  sheet = "Planilha1")

dados2
```

# Importando dados do Google Sheets com `gsheet`

Com o pacote `gsheet`, √© poss√≠vel importar dados diretamente do Google Sheets usando a fun√ß√£o `gsheet2tbl()`. Isso facilita o trabalho colaborativo e elimina a necessidade de downloads manuais.

**Contagens e agrupamentos simples com `dplyr`**

S√£o feitas contagens de observa√ß√µes agrupadas por `species`, `residue` e tamb√©m a combina√ß√£o entre `state` e `residue`. Essas an√°lises descritivas ajudam a entender a distribui√ß√£o dos dados.

**Filtrando e combinando subconjuntos**

Aqui s√£o extra√≠das observa√ß√µes espec√≠ficas de dois estados (RS e PR) e unidas com `rbind()`. Isso permite compara√ß√µes regionais em an√°lises posteriores.

**Selecionando colunas e criando subconjuntos anuais**

S√£o criados subconjuntos contendo apenas informa√ß√µes relevantes e filtrados por ano, permitindo an√°lises temporais.

**Selecionando colunas e criando subconjuntos anuais**

`tabyl()` do pacote `janitor` produz tabelas cruzadas simples e organizadas, √∫teis para relat√≥rios e an√°lises explorat√≥rias.

```{r}

library(gsheet)
dados_nuvem <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=465348652#gid=465348652")

dados_mg <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137")

dados_survey <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1118819738#gid=1118819738")

library(dplyr)
dados_survey |>
  group_by(species) |>
  count()

dados_survey |>
  group_by(residue) |>
  count()

dados_survey |>
  group_by(state, residue) |>
  count()

RS <- dados_survey |>
  filter(state== "RS")

PR <- dados_survey |>
  filter(state== "PR")

combinado <- rbind(RS, PR)


survey_b <- dados_survey |>
  dplyr:: select(year, state, species)

survey_2009 <- dados_survey |>
  dplyr:: select(year, state, species) |>
  filter(year== 2009)

survey_2010 <- dados_survey |>
  dplyr:: select(year, state, species) |>
  filter(year== 2010)

survey_2011 <- dados_survey |>
  dplyr:: select(year, state, species) |>
  filter(year== 2011)

library(janitor)
survey_b |>
  tabyl(state, species)

library(janitor)
survey_b |>
  tabyl(species, year)

library(ggplot2)


survey_b |>
  group_by(year, species) |>
  count() |>
  ggplot(aes(year, n, fill = species))+
  geom_col()+
  scale_fill_manual(values=c("Purple","yellow"))

survey_b |>
  group_by(year, species) |>
  count() |>
  ggplot(aes(year, n, fill = species))+
  geom_col()+
  scale_fill_grey()

survey_b |>
  group_by(year, species) |>
  count() |>
  ggplot(aes(year, n, fill = species, color= species))+
  geom_col()+
  scale_fill_viridis_d()


```

**Gr√°ficos de barras com `ggplot2`**

Neste gr√°fico de barras agrupadas, visualiza-se a frequ√™ncia de esp√©cies por ano. A paleta de cores √© personalizada. S√£o mostradas v√°rias varia√ß√µes desse gr√°fico:

-   `scale_fill_manual()` ‚Äî cores definidas manualmente;

-   `scale_fill_grey()` ‚Äî escala de cinza;

-   `scale_fill_viridis_d()` ‚Äî cores perceptualmente uniformes, boas para dalt√¥nicos.

**Boxplot com dados de magn√©sio**

Este gr√°fico compara o efeito de diferentes tratamentos com magn√©sio sobre o comprimento da les√£o. O uso de `geom_jitter()` evita sobreposi√ß√£o dos pontos, melhorando a visualiza√ß√£o.

```{r}
mg <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137")

library(ggplot2)
library(ggthemes)
plot_magnesio <- mg |>
  ggplot(aes(trat, comp))+
  geom_boxplot(fill = "white",
               outlier.colour = NA)+
  geom_jitter(width = 0.1)+
  scale_y_continuous(limits = c(0,20) )+
  labs(x= "Tratamento",
       y= "Comprimento (mm)",
       title = "Efeito do magn√©sio",
       subtitle = "Tamanho da les√£o de mancha",
       caption = "Fonte (SILVA, I. S. et al. 2025")+
  theme_clean()
plot_magnesio
```

**Boxplot para taxa de crescimento micelial**

Outro boxplot, agora para taxa de crescimento micelial por esp√©cie. As categorias s√£o reordenadas com `reorder()`, e o gr√°fico √© rotacionado (`coord_flip()`) para facilitar a leitura.

```{r}
micelial <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=959387827#gid=959387827")

library(ggplot2)
library(ggthemes) # Para usar o tema theme_clean()

plot_micelial <- micelial |> 
  ggplot(aes(x = reorder(especie, tcm), y = tcm)) +
  geom_boxplot(fill = "white", outlier.colour = NA) +
  geom_jitter(width = 0.1) +
  coord_flip() +
  labs(
    x = "Esp√©cie",
    y = "TCM (mm)",
    title = "Taxa de crescimento micelial",
    caption = "Fonte: SILVA, I. S. et al. 2025"
  ) +
  theme_clean()
plot_micelial
```

**Combinando m√∫ltiplos gr√°ficos com `patchwork`**

Utiliza-se o pacote `patchwork` para combinar os dois gr√°ficos anteriores lado a lado com anota√ß√µes (A, B, ...). O resultado √© salvo como imagem (`Combo1.png`), ideal para uso em relat√≥rios e artigos.

```{r}
library(patchwork)
(plot_magnesio|plot_micelial)+
  plot_annotation(tag_levels = "A")
ggsave("Combo1.png", bg = "white",
       width = 8, height = 4)
```

# Aula 03 ‚Äî Testes estat√≠sticos (t, ANOVA, Kruskal), visualiza√ß√£o e checagem de pressupostos

**Carregando e visualizando os dados do efeito do magn√©sio**

Neste trecho, utilizamos pacotes essenciais (`gsheet`, `ggplot2` e `tidyr`) para importar dados diretamente de uma planilha do Google Sheets. Os dados cont√™m medi√ß√µes de comprimento de les√£o sob diferentes tratamentos. Em seguida, fazemos uma visualiza√ß√£o preliminar por meio de um gr√°fico de dispers√£o para comparar os tratamentos.

### **Explorando os dados e realizando teste t para duas amostras independentes**

Aqui visualizamos as vari√°veis do objeto `dat_mg2`, convertemos o formato dos dados para wide, e comparamos os tratamentos "control" e "Mg2" por meio de um **teste t para amostras independentes**. Isso permite avaliar se h√° diferen√ßa significativa entre os dois grupos.

### **Alternativa ao teste t com f√≥rmula e visualiza√ß√£o dos resultados**

Agora utilizamos a f√≥rmula `comp ~ trat` dentro do teste t, com dados no formato longo. Tamb√©m utilizamos o pacote `ggpubr` para gerar um gr√°fico boxplot com anota√ß√£o do valor de **p**, facilitando a interpreta√ß√£o visual da compara√ß√£o estat√≠stica.

### **Testes de normalidade e homogeneidade de vari√¢ncia**

Esses testes s√£o premissas importantes para aplicar o teste t. O **teste de Shapiro-Wilk** avalia a normalidade dos dados, enquanto o **teste F de vari√¢ncias (var.test)** verifica a homogeneidade das vari√¢ncias entre os grupos.

```{r}

library(gsheet)
library(ggplot2)
library(tidyr)


dat_mg <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137")

dat_mg |> 
  ggplot2::ggplot(aes(trat, comp)) +
  ggplot2::geom_jitter(width = 0.1)

library(dplyr)

dat_mg2 <- dat_mg |> 
  pivot_wider(names_from = "trat", values_from = "comp") |>
  dplyr:: select(-rep)

names(dat_mg2)
glimpse(dat_mg2)
head(dat_mg2)



attach(dat_mg2)
t.test(control, Mg2,
       var.equal = FALSE)
t_results <- t.test(control, Mg2)

library(report)
report(t_results)


library(rstatix)

test <- t.test(comp ~ trat, data = dat_mg)

 # Instala o pacote
library(ggpubr)            # Carrega o pacote

# Gr√°fico boxplot com ggboxplot

library(ggpubr)

print(test)

# Crie o data frame com a compara√ß√£o e o valor de p

library(ggpubr)

library(ggpubr)

# Crie o data frame com a compara√ß√£o e o valor de p
test <- data.frame(
  group1 = "control",
  group2 = "Mg2",
  p.value = 2.423e-07,
  y.position = 18
)

p <- ggboxplot(dat_mg,
               x = "trat",
               y = "comp",
               color = "trat",
               palette = "jco")
p + stat_pvalue_manual(test, label = "p.value") +
  ylim(0, 20)

#Teste normalidade dos dados

shapiro.test(dat_mg2$Mg2)
shapiro.test(dat_mg2$control)
hist(dat_mg2$Mg2, main = "Histograma de Mg2", xlab = "Valores de comp")
hist(dat_mg2$control, main = "Histograma de Controle", xlab = "Valores de comp")
var.test(dat_mg2$Mg2, dat_mg2$control)

# Homogenidade das variancias e normalidade sao as premissas do test T

# Teste para saber se as variancias s√£o homogeneas - teste F

# F = 1.4781, num df = 9, denom df = 9, p-value = 0.5698 - N√£o rejeita a hipotese nula, ent√£o as variancias sao homogeas 

# O test T ainda pode ser utilizado quando as variancias n√£o sao homogeas.


```

### **Teste t para amostras pareadas (dependentes)**

Este conjunto de dados representa avalia√ß√µes feitas pelos mesmos avaliadores antes e depois de uma interven√ß√£o. Por isso, o teste t pareado √© apropriado. Utilizamos tamb√©m `pivot_wider` para estruturar os dados corretamente.

### **Visualiza√ß√£o e testes de normalidade e vari√¢ncia (caso pareado)**

Aqui comparamos os grupos graficamente e testamos normalidade e homogeneidade das vari√¢ncias antes de aplicar os testes t e Wilcoxon (param√©trico e n√£o-param√©trico, respectivamente).

```{r}
library(gsheet)
library(dplyr)
library(tidyr)

escala  <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1729131173#gid=1729131173")



escala_wider <- escala %>%
  pivot_wider(id_cols = rater, names_from = assessment, values_from = acuracia)

names(escala_wider)

t.test(escala_wider$Unaided, escala_wider$Aided1,
       paired = TRUE,
       var.equal = FALSE)

escala |>
  ggplot(aes(x = assessment, y = acuracia)) +
  geom_boxplot() +
  labs(title = "Compara√ß√£o da Acur√°cia por Assessment",
       x = "Assessment",
       y = "Acur√°cia")


# Filtrar e extrair a acur√°cia para os grupos
unaided <- escala %>%
  filter(assessment == "Unaided") %>%
  dplyr:: select(acuracia) %>%
  pull()

aided <- escala %>%
  filter(assessment == "Aided1") %>% # Assumindo que o outro grupo √© "Aided1"
  dplyr:: select(acuracia) %>%
  pull()

# Teste de compara√ß√£o de vari√¢ncias
var.test(unaided, aided)

# Histogramas
hist(unaided, main = NULL, xlab = NULL, ylab = NULL)
hist(aided, main = NULL, xlab = NULL, ylab = NULL)

# Testes de normalidade de Shapiro-Wilk
shapiro.test(unaided)
shapiro.test(aided)


# Teste t N√ÉO pareado (Welch, assumindo vari√¢ncias possivelmente desiguais)
t.test(unaided, aided, paired = FALSE, var.equal = FALSE)

# Teste de Wilcoxon N√ÉO pareado
wilcox.test(unaided, aided, paired = FALSE)
```

**ANOVA: compara√ß√£o entre mais de dois grupos**

Usamos um conjunto de dados sobre o crescimento micelial para aplicar **ANOVA**, verificar pressupostos (normalidade e homogeneidade de vari√¢ncia), e seguir com compara√ß√µes m√∫ltiplas usando `emmeans`.

```{r}

library(gsheet)
library(dplyr)
library(ggplot2) # 
micelial <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=959387827#gid=959387827")

micelial %>%
  ggplot(aes(x = especie, y = tcm)) +
  geom_boxplot(outlier.color = NA) +
  geom_jitter(width = 0.1)

    
anova1 <- aov(tcm ~ especie, data = micelial)
anova2 <- lm(tcm ~ especie, data = micelial)
 
anova(anova1)
anova(anova2)
hist(residuals(anova1))
shapiro.test(residuals(anova1))

# Rejeita hipotese nula p- valor 2.028e-07.

# Shapiro test =  p-value = 0.8782 n√£o rejeita.

bartlett.test(tcm ~ especie, data = micelial)
library(rstatix)
levene_test(tcm ~ especie, data = micelial)


# Para esse conjunto de dados, tem duas premissas legais.

library(emmeans)

m = emmeans(anova2, ~ especie)
m

library(multcomp)
cld(m)
pairs(m) # Ao inves da matriz, faz uma tabela
pwpm(m) # Medias (comparando matriz)

```

### **Transforma√ß√µes, ANOVA e testes n√£o-param√©tricos**

Com o conjunto `InsectSprays`, comparamos a efic√°cia de diferentes inseticidas por ANOVA. Aplicamos transforma√ß√µes para normalizar os dados e, alternativamente, usamos **Kruskal-Wallis**, que √© um teste n√£o-param√©trico para mais de dois grupos.

```{r}
# Novo conjundo de dados

library(ggplot2)
library(rstatix)
insetos = InsectSprays # Comparar insetiscidas diferentes

insetos |>
  ggplot(aes(x = spray, y = count)) +
  geom_boxplot(outlier.color = NA) +
  geom_jitter(width = 0.1)
bartlett.test(count ~ spray, data = insetos)

m2 <- lm(count ~ spray, data = insetos)
hist(residuals(m2))
shapiro_test(residuals(m2))
qqnorm(residuals(m2))
qqline(residuals(m2))

## Alternativa 1 - transformar a resposta


library(rstatix) # Para shapiro_test
library(report)   # Para a fun√ß√£o report

m3 <- lm(rank(count + 0.1) ~ spray, data = insetos)
hist(residuals(m3), main = "Histograma dos Res√≠duos", xlab = "Res√≠duos")
shapiro_test(residuals(m3))
qqnorm(residuals(m3))
qqline(residuals(m3))
anova(m3)


m33 <- emmeans(m3, ~ spray, type = "response")
cld(m33)
plot(m33)


# Fazer o lm sem tranformar ***

# Alternativa 2 - n√£o parametrico #

# O teste n√£o-param√©trico equivalente √† ANOVA √© o Teste de Kruskal-Wallis.

kruskal.test(count ~ spray, data = insetos)
kruskal_test(insetos, count ~ spray)

library(agricolae)
kruskal(insetos$count, insetos$spray, group = TRUE,
        console = TRUE)
```

## **AULA 04 ‚Äì Diagn√≥stico de Res√≠duos com DHARMa**

### **Objetivo:**

Avaliar a qualidade do modelo ajustado `m3` utilizando o pacote **DHARMa**, que fornece diagn√≥sticos de res√≠duos simulados para modelos lineares e generalizados, testando pressupostos como normalidade e homocedasticidade.

```{r}

library(DHARMa)
m3
plot(simulateResiduals(m3))




```

## **AULA 05 ‚Äì An√°lise de Experimentos com Blocos e Transforma√ß√µes**

### **Importa√ß√£o e prepara√ß√£o dos dados de campo**

Neste trecho, os dados experimentais de campo s√£o importados do Google Sheets e as vari√°veis categ√≥ricas s√£o corretamente convertidas em fatores. Tamb√©m convertemos a vari√°vel `FER` para num√©rica, garantindo que esteja no formato adequado para an√°lises.

### **Visualiza√ß√£o explorat√≥ria da vari√°vel resposta**

Antes de ajustar o modelo, √© fundamental visualizar a dispers√£o dos dados para cada tratamento e poss√≠veis tend√™ncias nos valores de `PROD` (produtividade).

### **Ajuste de modelo linear com transforma√ß√£o logar√≠tmica**

Aqui, ajustamos um modelo linear para a vari√°vel `FER` (fermenta√ß√£o), transformada via logaritmo natural, considerando os efeitos fixos de bloco e tratamento.

### **Verifica√ß√£o da signific√¢ncia via ANOVA**

Utilizamos a ANOVA para avaliar a signific√¢ncia dos efeitos de tratamento e bloco sobre a vari√°vel resposta transformada.

### **Diagn√≥stico de res√≠duos do modelo**

Avaliamos os res√≠duos simulados do modelo com o pacote **DHARMa**, verificando poss√≠veis desvios das premissas de normalidade e homocedasticidade.

### **Estimativas das m√©dias marginais (EMMeans)**

Calculamos as m√©dias ajustadas para cada tratamento, as visualizamos e comparamos com letras de signific√¢ncia.

### **Correla√ß√µes entre vari√°veis cont√≠nuas**

Calculamos correla√ß√µes entre vari√°veis importantes do experimento (`FER`, `PROD`, `DFC`) para investigar rela√ß√µes lineares entre elas.

```{r}
library(gsheet)
library(dplyr)
library(ggplot2)
library(DHARMa)
library(emmeans)
library(multcomp)

# Importando os dados
campo <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=866852711#gid=866852711")

# Convertendo vari√°veis em fatores corretamente
campo <- campo |> 
  mutate(TRAT = factor(TRAT),
         BLOCO = factor(BLOCO),
         FER = as.numeric(FER)) # Convertendo FER para num√©rico caso esteja como texto

# Visualizando os dados
ggplot(campo, aes(x = TRAT, y = PROD)) + 
  geom_jitter(width = 0.1) + 
  stat_summary(fun.data = "mean_cl_boot", colour = "red")

# Ajustando o modelo correto
m_campo <- lm(log(FER) ~ BLOCO + TRAT, data = campo)

# Verificando ANOVA
anova(m_campo)

# Diagn√≥stico de res√≠duos
plot(simulateResiduals(m_campo))

# M√©dias marginais estimadas
means_campo <- emmeans(m_campo, ~ TRAT, type = "response")

# Plotando e analisando as m√©dias
plot(means_campo)
means_campo
library(agricolae)
cv.model(m_campo)
cld(means_campo)
pwpp(means_campo)
pwpm(means_campo) # Compara√ß√£o dos tratamentos numa matriz

cor(campo$FER, campo$PROD)
cor.test(campo$FER, campo$DFC)

campo |> 
  ggplot(aes(FER, DFC)) +
  geom_point() +  # Corre√ß√£o aqui
  geom_smooth(method = "lm")


```

## **Modelo Linear Misto ‚Äì An√°lise com Dados de Milho**

### **Importa√ß√£o e visualiza√ß√£o dos dados**

Importamos outro conjunto de dados com experimentos em milho e visualizamos os efeitos dos h√≠bridos e m√©todos sobre o √≠ndice.

### **Prepara√ß√£o dos dados e ajuste de modelo misto**

Criamos uma vari√°vel de intera√ß√£o entre h√≠brido e bloco, e ajustamos um modelo linear misto com efeito aleat√≥rio de `hybrid_block`.

### **ANOVA e diagn√≥stico do modelo misto**

Utilizamos a fun√ß√£o `Anova()` para verificar a signific√¢ncia dos efeitos fixos e `DHARMa` para verificar res√≠duos simulados.

### **Ajuste de novo modelo para produtividade**

Ajustamos um segundo modelo considerando a vari√°vel resposta `yield`, incorporando estrutura hier√°rquica com blocos aninhados em h√≠brido.

### **Ajuste de novo modelo para produtividade**

Ajustamos um segundo modelo considerando a vari√°vel resposta `yield`, incorporando estrutura hier√°rquica com blocos aninhados em h√≠brido.

### **Rela√ß√£o entre √≠ndice e produtividade**

Exploramos a correla√ß√£o entre `index` e `yield`, tanto visualmente quanto numericamente, calculando o coeficiente de determina√ß√£o (R¬≤).

```{r}

library(gsheet)
library(lme4)
library(car)
library(DHARMa)
library(ggplot2)
library(dplyr)
library(multcomp)
library(emmeans)

# Importando os dados
milho <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1345524759#gid=1345524759")

# Visualiza√ß√£o dos dados
milho |> 
  ggplot(aes(hybrid, index, color = method)) +
  geom_jitter(width = 0.1) +
  coord_flip()

# Criando a intera√ß√£o de h√≠brido e bloco
milho <- milho |> mutate(hybrid_block = interaction(hybrid, block))

# Ajuste do modelo linear misto
m_milho <- lmer(index ~ hybrid * method + (1 | hybrid_block), data = milho)

# ANOVA
Anova(m_milho)

# Diagn√≥stico de res√≠duos
plot(simulateResiduals(m_milho))

m_milho2 <- lmer(yield ~ hybrid * method + (1 | block:hybrid_block), data = milho)
car::Anova(m_milho2)
plot(simulateResiduals(m_milho2))

media_milho2 <- emmeans(m_milho2, ~ method | hybrid)
cld(media_milho2, Letters = letters)

# Corre√ß√£o do erro de digita√ß√£o: "indez" para "index"
milho |> 
  ggplot(aes(index, yield)) +
  geom_point() +
  geom_smooth(method = "lm")


cor1 <- cor(milho$index, milho$yield)
cor1^2 * 100
cor.test(milho$index, milho$yield)



```

# AULA 06 ‚Äì Transforma√ß√µes Box-Cox, Regress√£o e Modelos Mistos

### **Transforma√ß√£o Box-Cox em dados com problemas de normalidade**

A transforma√ß√£o de Box-Cox √© √∫til quando os dados n√£o atendem aos pressupostos de normalidade e homocedasticidade. O m√©todo busca encontrar uma pot√™ncia (lambda) ideal para transformar a vari√°vel resposta e melhorar o ajuste do modelo linear. Aqui, usamos dados do conjunto `InsectSprays` e aplicamos a transforma√ß√£o em `count`.

```{r}

library(MASS)
library(DHARMa)
library(tidyverse)
library(agricolae)

insects <- InsectSprays
m1 <- lm(sqrt(count) ~ spray, data = insects)
plot(m1)

b <- boxcox(lm(count + 0.1 ~ 1, data = insects))
lambda <- b$x[which.max(b$y)]
lambda

insects <- insects |>
  mutate(count2 = (count^lambda - 1) / lambda,
         count3 = sqrt(count))

hist(insects$count)

m1 <- lm(count2 ~ spray, data = insects)
plot(m1)

# Usar quando as premissas dos dados usando log e raiz quadrada nao est√£o ok




```

> **Nota:** A transforma√ß√£o Box-Cox √© especialmente √∫til quando transforma√ß√µes usuais como log ou raiz quadrada n√£o resolvem os problemas dos res√≠duos do modelo.

### **An√°lise de regress√£o simples por experimento**

Nesta se√ß√£o, usamos dados experimentais sobre a porcentagem de in√≥culo e o n√∫mero de plantas infectadas. Inicialmente, visualizamos os dados e depois realizamos uma regress√£o linear simples para cada experimento individualmente (exp1, exp2 e exp3).

```{r}
# Importando os dados

library(gsheet)
estande <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=401662555#gid=401662555")

# Ser√° que tem efeito a concentra√ß√£o de inoculo no n√∫mero de plantas infectadas?


library(ggplot2)

estande |>
ggplot(aes(x = trat, y = nplants)) +
  geom_point() +
  geom_smooth(method = "lm",  se = FALSE,
              color = "black")+
  facet_wrap( ~exp)+
  theme_minimal()+
  labs(x = " % de inoculo na semente",
       y = "N√∫mero de Plantas")
```

# Regress√µes individuais por experimento

```{r}
exp1 <- estande |>
  filter(exp == 1)

m_exp1 <- lm(nplants ~ trat, data = exp1)
summary(m_exp1)

exp1 |>
  ggplot(aes(trat, nplants))+
  geom_point()+
    ylim(20,60)

exp2 <- estande |>
  filter(exp == 2)

m_exp2 <- lm(nplants ~ trat, data = exp2)
summary(m_exp2)

exp3 <- estande |>
  filter(exp == 3)

m_exp3 <- lm(nplants ~ trat, data = exp3)
summary(m_exp3)
```

### **Modelo linear misto para considerar estrutura hier√°rquica**

Com dados oriundos de m√∫ltiplos experimentos com blocos, um **modelo misto** √© mais apropriado para considerar a varia√ß√£o entre blocos dentro de cada experimento. Isso permite generalizar os resultados sem ignorar fontes de varia√ß√£o.

```{r}
library(lme4)
library(car)
library(lme4)
m_misto <- lmer(nplants ~ trat + (1 | exp/bloco), data = estande)
summary(m_misto)
confint(m_misto)
car::Anova(m_misto)

```

### **Representa√ß√£o visual de modelos ajustados**

Aqui usamos o `ggplot2` para representar visualmente o efeito de `trat` sobre `nplants`, comparando com diferentes linhas de tend√™ncia ajustadas nos modelos anteriores (com diferentes interceptos e inclina√ß√µes).

```{r}
library(ggplot2)

estande |>
  ggplot(aes(trat, nplants, color = factor(exp))) +
  geom_point() +
  # geom_smooth(method = "lm", se = FALSE) +
  geom_abline(intercept = 69.74, slope = -0.568, linewidth = 2) +
  geom_abline(intercept = 43, slope = - 0.73, linetype = "dashed") +
  geom_abline(intercept = 96, slope = - 0.40, linetype = "dashed")
```

## **An√°lise de Dose-Resposta (DRC) e c√°lculo de EC50**

Nesta se√ß√£o, utilizamos o pacote `drc` para ajustar modelos de regress√£o n√£o-linear do tipo log-log√≠stico, que s√£o ideais para dados de dose-resposta. Avaliamos o efeito da dose sobre a germina√ß√£o f√∫ngica, e estimamos a **dose efetiva 50% (EC50)** para o isolado FGT43.

Ajuste do modelo log-log√≠stico para um isolado espec√≠fico (FGT43)

### **Estimativa de EC50 para m√∫ltiplos isolados com `ec50estimator`**

Neste passo, usamos um pacote espec√≠fico para automatizar a estimativa de EC50 para todos os isolados presentes no conjunto de da

```{r}

# Importando os dados

library(dplyr)
library(ggplot2)
library(drc)

# Gr√°fico com os dados
fungi <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=465348652#gid=465348652")

fungi |>
  dplyr::group_by(code, dose) |>
  summarise(germination = mean(germination), .groups = "drop") |>
  ggplot(aes(dose, germination)) +
  geom_point() +
  facet_wrap(~ code)

# Ajuste do modelo para FGT43

FGT43 <- fungi |>
  filter(code == "FGT43")

m43 <- drm(germination ~ dose,
           data = FGT43,
           fct = LL.3())

plot(m43)
ED(m43, 50)

library("ec50estimator")

df_ec50 = estimate_EC50(germination ~dose,
                        data = fungi,
                        isolate_col = "code",
                        strata_col = "state",
                        interval = "delta",
                        fct = drc:: LL.3())
df_ec50 |>
ggplot(aes(reorder(ID, Estimate), Estimate))+
  geom_point()+
  coord_flip()

df_ec50 |>
ggplot(aes(x = Estimate))+
  geom_histogram(bins = 5, color = "white")


```

Neste exerc√≠cio, utilizaremos um conjunto de dados relacionados √† **ferrugem do cafeeiro (*Hemileia vastatrix*) na Eti√≥pia**. O objetivo √© demonstrar como importar, visualizar e representar espacialmente dados fitopatol√≥gicos com ferramentas modernas de R. A base foi obtida por meio de levantamento em fazendas cafeeiras, contendo registros de latitude, longitude e incid√™ncia da doen√ßa.

Utilizamos a fun√ß√£o `gsheet2tbl()` do pacote **gsheet** para importar os dados diretamente da nuvem (Google Sheets). O objeto `cr` agora cont√©m as observa√ß√µes de incid√™ncia de ferrugem do caf√©, com coordenadas geogr√°ficas de coleta.

```{r}
library(gsheet) 
cr <-  gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1871397229#gid=1871397229")  
```

Usamos a fun√ß√£o `datatable()` do pacote **DT** para gerar uma tabela interativa, facilitando a visualiza√ß√£o e a explora√ß√£o dos dados. Essa visualiza√ß√£o √© √∫til para verificar rapidamente colunas como `lat`, `lon` e `inc`.

```{r}
library(DT) 
datatable(cr) 
```

Essa √© uma visualiza√ß√£o b√°sica dos pontos geogr√°ficos de coleta. A fun√ß√£o `geom_point()` do **ggplot2** plota cada observa√ß√£o com base em sua longitude (`lon`) e latitude (`lat`).

Importamos os limites administrativos da Eti√≥pia em formato espacial usando o pacote **rnaturalearthhires**. O resultado (`ETH`) √© um objeto `sf` que pode ser usado com `ggplot2`.

Este gr√°fico mostra um mapa detalhado da Eti√≥pia com os pontos de coleta georreferenciados. A intensidade da cor representa a **incid√™ncia da ferrugem do cafeeiro**, permitindo identificar padr√µes geoespaciais da doen√ßa.

Salva o mapa gerado no formato `.png`, com fundo branco e largura de 10 polegadas. Isso permite utilizar a imagem em apresenta√ß√µes, relat√≥rios ou publica√ß√µes.

```{r}

library(tidyverse)

cr |> 
  ggplot(aes(lon, lat))+
  geom_point()

library(rnaturalearth)
library(rnaturalearthhires)

remotes:: install_github("ropensci/rnaturalearthhires")

ETH <- ne_states(country = "Ethiopia", returnclass = "sf")

library(tidyverse)
library(ggthemes)
library(ggspatial)


ETH |>
ggplot()+ 
  geom_sf(fill = "gray80") + 
  geom_point(data = cr, aes(lon, lat, color = inc))+
  scale_color_viridis_c()+
  theme_minimal()+
  theme(legend.position = "bottom")+
  annotation_scale(location = "tl")+
  annotation_north_arrow(location = "br", which_north = "true")+
  labs(title = "Ferrugem do caf√© na Eti√≥pia", x = "Longitude", Y = "Latiitude", subtitle = "Levantamento em fazendas", caption = "Fonte: Del Pnte et al. (2025)", color = "Incid√™ncia (%)")
ggsave("mapa_etiopia.png", bg = "white", width = 10)
```
